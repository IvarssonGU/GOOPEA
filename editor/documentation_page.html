<!DOCTYPE html>
<html lang="en" style="background-color: var(--background);">
<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="./static/css/documentation_page.css">
	<link rel="stylesheet" href="./static/css/navbar.css">
	<link rel="icon" type="image/x-icon" href="/images/favicon.ico">

    <title>GOOPEA documentation</title>
</head>
<body onload="document.body.classList.add('show')">
    <div class="nav" id="nav">
		<a href="index.html" class="logo">GOOPEA playground</a>
		<a onclick="change_page(0)">Editor</a>
		<a onclick="change_page(1)">Examples</a>
		<a href="documentation_page.html" class="current-page">Documentation</a>
		<a onclick="change_theme(2)" id="theme-button"><p>ðŸŒ™&#Xfe0e;</p></a>
	</div>
	
	<table id="container-table">
		<tr>
			<td id="control-row">
				<button onclick="expand_all()" class="styled-button control-button">Expand all</button>
				<button onclick="collapse_all()" class="styled-button control-button">Collapse all</button>
			</td>
		</tr>
		<tr>
			<td>
				<button class="toggle-header">Introduction</button>
				<div class="toggle-content">
					<p class="multiline"><b>Kandidatarbete</b>: This was created by group DATX11 DIT561-VT25-50. This is the playground aspect of a Bachelor's thesis 
						on the advantage of having FIP functionality in a programming language</p>
					<p class="multiline"><b>Functional Programming Languages</b> have their roots in the lambda-calculus and model computations by function 
						composition, as opposed to traditional languages that model it by a sequence of instructions to execute. They can therefore 
						be very convenient and elegant when modelling recursive relationships, for example.</p>
					<p class="multiline"><b>Functional In-Place</b>: a way to improve performance by reusing memory instead of the (de)allocations done by 
						typical functional programming languages. Since computers are naturally stateful objects, unlike stateless functional 
						code, the translation from functional code to machine code will often be slower than its imperative counterpart. The 
						level of abstraction also sometimes makes it hard or impossible to implement certain classes of optimizations that 
						lower languages can. That often makes functional languages unconducive for projects where performance is critical</p>
				</div>
			</td>
		</tr>
		<tr>
			<td>
				<button class="toggle-header">Editor</button>
				<div class="toggle-content">

					<table width="100%">
						<tr>
							<td>
								<button class="toggle-header subsection">Keyboard shortcuts</button>
								<div class="toggle-content">
									<p class="tabbed"><mark><b>Ctrl-/</b></mark>: Toggle line comment</p>
									<p class="tabbed"><mark><b>Ctrl-D</b></mark>: Delete the current line</p>
									<p class="tabbed"><mark><b>Ctrl-S</b></mark>: Like the compile button except it doesn't switch tab; if you 
										have an error, try the shortcut again to see if you have more errors. Or click the button if you're into that :/</p>
									<p class="tabbed"><mark><b>Ctrl-Q</b></mark>: Like clicking the run button. Note that if you do this while active in the editor 
										the output will only be visible for as long as you hold down the keys</p>
									<p class="tabbed"><mark><b>Alt-Down</b></mark>: Copy current line and insert-paste it on line below</p>
									<p class="tabbed"><mark><b>Shift-Alt-Up/Down</b></mark>: Swap the active line with the line above/below</p>
									<p class="tabbed"><mark><b>Ctrl-Space</b></mark>: Autocomplete with the keywords and other words already on the page. 
										If there is only one match it is automatically completed. If there are multiple and you hit tab, the first word in 
										the list will be used</p>
								</div>
							</td>
						</tr>
						<tr>
							<td>
								<button class="toggle-header subsection">Examples</button>
								<div class="toggle-content">
									<p class="tabbed">It is important to note that not all examples compile as they are, so they are mostly just give you an idea of the language</p>
									<p class="tabbed"><mark><b>Reverse</b></mark>: reverses the list created in main and maybe sums it depending on which main is not commented</p>
									<p class="tabbed"><mark><b>Treeflip</b></mark>: flips a tree around the vertical axis and then sums it</p>
									<p class="tabbed"><mark><b>Arithmetic</b></mark>: operations</p>
									<p class="tabbed"><mark><b>Complex match</b></mark>: converts a Cat to a Dog and then returns that</p>
									<p class="tabbed"><mark><b>Multiple Return Values</b></mark>: two functions that return more than one value</p>
									<p class="tabbed"><mark><b>Type error</b></mark>: passes a variable of a type to a function that doesn't take said type</p>
									<p class="tabbed"><mark><b>Utuple</b></mark>: pattern matching :D</p>
									<p class="tabbed"><mark><b>Zipper tree</b></mark>: increments Tips by 1 using a zipper</p>
									<p class="tabbed"><mark><b>Bools</b></mark>: Fibonacci sequence by matching on True/False</p>
									<p class="tabbed"><mark><b>Dag</b></mark>: demonstrates building using enums</p>
									<p class="tabbed"><mark><b>In Order</b></mark>: returns a List containing parameter Tree's Ints in order from left to right</p>
									<p class="tabbed"><mark><b>Reuse different type</b></mark>: matches on parameter to convert between enums/datatypes</p>
								</div>
							</td>
						</tr>
					</table>
				</div>
			</td>
		</tr>
		<tr>
			<td>
				<button class="toggle-header">Language</button>
				<div class="toggle-content">
					<table width="100%">
						<tr>
							<td>
								<button class="toggle-header subsection">A function's type declaration</button>
								<div class="toggle-content">
									<p><b>fip (parameters): (returns)</b></p>
									<p><b>(parameters): (returns)</b></p>
									<p class="tabbed">The optional 'fip' keyword declares whether or not the function is written to use fip functionality or not</p>
									<p class="tabbed">Both the parameter and returns are tuples of datatypes or enums, separate them with commas: <mark>(x, y, z)</mark></p>
									<p class="tabbed">If a function takes no parameters or doesn't return anything, use an empty tuple <mark>()</mark></p>
									<p class="tabbed">If a function takes or returns only one variable, you can just write that datatype/enum, e.g. "Tree", "Int"</p>
									<p class="tabbed">See the examples "Reverse" and "Multiple Return Values" for how this looks</p>
									<p></p>
								</div>
							</td>
						</tr>
						<tr>
							<td>
								<button class="toggle-header subsection">Function declaration</button>
								<div class="toggle-content">
									<p class="multiline">The function declaration goes on the line under the type declaration. The name of the function is first, 
										and does not start with a capital letter. The names of the parameters whose types were declared earlier are then given. 
										The "Reverse" example shows how functions are declared with 0, 1, and 2+ parameters.
									</p>
								</div>
							</td>
						</tr>
						<tr>
							<td>
								<button class="toggle-header subsection" id="keywords-header">Keywords</button>
								<div class="toggle-content">
									<p class="multiline">Keywords are words that are reserved (can't be used for anything else) because they are special in 
										the eye of the compiler (have a predefined purpose for the structure and syntax of the program and language). They are 
										also case-sensitive.
									</p>
									
									<!-- <p class="tabbed"><mark><b>match</b></mark>: Pattern matching!! Check out "complex match" example!!!</p> -->
									<button class="toggle-header subsection subsub"><mark><b>match</b></mark>: Pattern matching!!</button>
									<div class="toggle-content">
										<table id="doc-table" class="tabbed" width="100%">
											<tr>
												<td>
													<p>Take, for example, this snippet from "complex match" example:</p>
												</td>
											</tr>
											<tr>
												<td class="code-snippet-cell">
													<span style="white-space: pre-wrap;">Int: Int
fib i = match i {
	0: 1,
	1: 1,
	n: fib (i-1) + fib(i-2)
};</span>
												</td>
											</tr>
											<tr>
												<td>
													<p><mark>fib i</mark> will return 1 if i=0 or i=1 (that is to say, i matches the values 0 or 1), and fib (i-1) + fib(i-2) in all other cases</p>
												</td>
											</tr>
										</table>
									</div>
									<!-- <p class="tabbed"><mark><b>let _ in _</b></mark>: let "variable = the return value of function" (first _) in "this context" (second _)</p> -->
									<button class="toggle-header subsection subsub"><mark><b>let _ in _</b></mark>: let "variable = the return value of function" in "this context"</button>
									<div class="toggle-content">
										<table id="doc-table" class="tabbed" width="100%">
											<tr>
												<td>
													<p>Take, for example, these snippets from the "complex match" and "utuple" examples:</p>
												</td>
											</tr>
											<tr>
												<td class="code-snippet-cell">
													<span style="white-space: pre-wrap;">(): Int
letUnbox = let x = 3 in x;
</span>
												</td>
											</tr>
											<tr>
												<td>
													<p>This is essentially <mark>letUnbox = 3</mark> or <mark>letUnbox = x</mark> if we already know that x = 3</p>
												</td>
											</tr>
											<tr>
												<td class="code-snippet-cell">
													<span style="white-space: pre-wrap;">main = let (a, b) = nums() in match a {
Nothing: match b { Just b: b, Nothing: 0},
Just x: match b { Just b: x * b + b, Nothing: 0}
};</span>
												</td>
											</tr>
											<tr>
												<td>
													<p>As <mark>nums()</mark> returns (Nothing, 5 * 2 + 9 * 20), <mark>(a, b) = nums() = (Nothing, 190)</mark>, 
													and then main says <mark>match a</mark> which will then match the Nothing, and (through another match) return b (190)</p>
												</td>
											</tr>
										</table>
									</div>
									<!-- <p class="tabbed multiline"><mark><b>enum</b></mark>: Creates a user-defined datatype. The name of an enum starts with a capital letter. 
										See examples "Complex match" and "Multiple return values"</p> -->
									<button class="toggle-header subsection subsub"><mark><b>enum</b></mark>: Creates a user-defined datatype. The name of an enum starts with a capital letter</p></button>
									<div class="toggle-content">
										<table id="doc-table" class="tabbed" width="100%">
											<tr>
												<td>
													<p>Take, for example, this snippet from "multiple return values" example:</p>
												</td>
											</tr>
											<tr>
												<td class="code-snippet-cell">
													<span style="white-space: pre-wrap;">enum List = Nil, Cons(List, Int);
enum Maybe = None, Some Int;</span>
												</td>
											</tr>
											<tr>
												<td>
													<p>A function that returns a <mark>Maybe</mark> returns either <mark>None</mark> or <mark>Some _</mark> where _ is any Int</p>
													<p>Declaring a list can be as short as List(Cons(Nil, 5)) or as long as the one in the Treeflip example's build function</p>
												</td>
											</tr>
										</table>
									</div>
									<p class="tabbed"><mark><b>fip</b></mark>: declare a function to use fip, see "a function's type declaration"</p>
									<p class="tabbed"><mark><b>Int</b></mark>: integer datatype</p>
									<p class="tabbed"><mark><b>True/False</b></mark>: boolean datatypes</p>
								</div>
							</td>
						</tr>
						<tr>
							<td>
								<button class="toggle-header subsection" id="constructors-header">Constructors</button>
								<div class="toggle-content">
									<p class="multiline">Constructors are used to create objects. Use them in enum definitions and declarations. See 
										"multiple return values" example. You can use any word you like that isn't a keyword and starts with a capital 
										letter made up of only letters. These are the ones you can see in the examples and have special syntax 
										highlighting because of it:
									</p>

									<table id="doc-table" class="tabbed" width="100%">
										<tr>
											<td>
												<p><mark><b>Cons</b></mark></p>
												<p><mark><b>Node</b></mark></p>
												<p><mark><b>Just</b></mark></p>
												<p><mark><b>Maybe</b></mark></p>
											</td>
											<td>
												<p><mark><b>Empty</b></mark></p>
												<p><mark><b>Nil</b></mark></p>
												<p><mark><b>None</b></mark></p>
												<p><mark><b>Nothing</b></mark></p>
											</td>
										</tr>
									</table>
								</div>
							</td>
						</tr>
						<tr>
							<td>
								<button class="toggle-header subsection">Other functions</button>
								<div class="toggle-content">
									<p> Here are some other prewritten functions that you can paste into your code if you want, sorted by what they pertain to</p>

									<table>
										<tr>
											<td>
												<button class="toggle-header subsection subsub"><mark><b>List</b></mark></button>
												<div class="toggle-content">
													<table id="doc-table" class="tabbed" width="100%">
														<tr>
															<td class="code-snippet-cell">
																<span style="white-space: pre-wrap;">enum List = Nil, Cons(Int, List);

(List, List): List
reverseHelper(list, acc) = match list {
	Nil: acc,
	Cons(x, xs): reverseHelper(xs, Cons(x, acc))
};

List: List
reverseList list = reverseHelper(list, Nil);

List: Int
sumList list = match list {
	Nil: 0,
	Cons(x, xs): x + sumList xs
};

List: Int
lenList list = match list {
	Nil: 0,
	Cons(x, xs): 1 + lenList xs
};

(List, Int): List
appendList(list, a) = match list {
	Nil: Cons(a, Nil),
	Cons(x, xs): Cons(x, appendList(xs, a))
};

(List, List): List
concatList(list1, list2) = match list1 {
	Nil: list2,
	Cons(x, xs): Cons(x, concatList(xs, list2))
};

(Int, Int): List
rangeListp(start, stop) = match start <= stop {
	True: Cons(start, rangeListp((start + 1), stop)),
	False: Nil
};

(Int, Int): List
rangeListn(start, stop) = match start >= stop {
	True: Cons(start, rangeListn((start - 1), stop)),
	False: Nil
};

(Int, Int): List
rangeList(start, stop) = match start <= stop {
	True: rangeListp(start, stop),
	False: rangeListn(start, stop)
};

(Int, Int, Int): List
randList(seed, len, mod) = match len > 0 {
	True: let a = next seed in 
		Cons((a % mod + mod) % mod, randList(a, len - 1, mod)),
	False: Nil
};</span>
															</td>
														</tr>
													</table>
												</div>
											</td>
										</tr>
										<tr>
											<td>
												<button class="toggle-header subsection subsub"><mark><b>Rand</b></mark></button>
												<div class="toggle-content">
													<table id="doc-table" class="tabbed" width="100%">
														<tr>
															<td class="code-snippet-cell">
																<span style="white-space: pre-wrap;">Int: Int
next x = x * 1664525 + 1013904223;</span>
															</td>
														</tr>
													</table>
												</div>
											</td>
										</tr>
										<tr>
											<td>
												<button class="toggle-header subsection subsub"><mark><b>Tree</b></mark></button>
												<div class="toggle-content">
													<table id="doc-table" class="tabbed" width="100%">
														<tr>
															<td class="code-snippet-cell">
																<span style="white-space: pre-wrap;">enum BST = Empty, Node(BST, Int, BST);

(BST, Int): BST
insert(tree, value) = match tree {
	Empty: Node(Empty, value, Empty),
	Node(left, x, right): match value == x {
		True: Node(left, x, right),
		False: match value < x {
			True: Node(insert(left, value), x, right),
			False: Node(left, x, insert(right, value))
		}
	}
};

(BST, List): BST
insertList(tree, list) = match list {
	Cons(x, xs): insertList(insert(tree, x), xs),
	Nil: tree
};

BST: List
flatten(tree) = match tree {
	Empty: Nil,
	Node(left, x, right): concatList(concatList(flatten(left), Cons(x, Nil)), flatten(right))
};

List: List
sortedElems(list) = let tree = insertList(Empty, list) in flatten(tree);</span>
															</td>
														</tr>
													</table>
												</div>
											</td>
										</tr>
									</table>
								</div>
							</td>
						</tr>
						<tr>
							<td>
								<button class="toggle-header subsection">Intermediate Representations (IRs)</button>
								<div class="toggle-content">
									<p class="multiline"> An intermediate representation is a step the compiler makes between the source code
										and the target code language. The three IRs for GOOPEA can be viewed in the "Editor" page under the "Compilation" tab: 
										stir (Sequentially Transformed IR), rc (RefCounted), and reuse.
										Note: the reuse IR is only different from stir if there is something to reuse (fip keyword used).
									</p>
								</div>
							</td>
						</tr>
					</table>
				</div>
			</td>
		</tr>
		<!-- toggle-list formula -->
		<!-- <tr>
			<td>
				<button class="toggle-header">section Visible Header</button>
				<div class="toggle-content">
					<p><b>bold stuff</b>: description</p>

					<table width="100%">
						<tr>
							<td>
								<button class="toggle-header subsection">subsection Visible Header</button>
								<div class="toggle-content">
									<p><b>bold stuff</b>: description</p>
								</div>
							</td>
						</tr>
						<tr>
							<td>
								<button class="toggle-header subsection">subsection Visible Header</button>
								<div class="toggle-content">
									<p><b>bold stuff</b>: description</p>
								</div>
							</td>
						</tr>
					</table>
				</div>
			</td>
		</tr> -->
		<!-- end formula -->
	</table>
	
	<script src="./static/js/documentation_page.js"></script>
	<script src="./static/js/navbar.js"></script>
</body>
</html>