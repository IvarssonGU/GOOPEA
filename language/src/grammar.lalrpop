use crate::ast::*;
use std::str::FromStr;

grammar;

identifier = r"";

pub Program: Program = {
    Definition* => Program(<>)
}

VID: VID = r"[a-z]\w*"  => VID(<>.to_string());
AID: AID = r"[A-Z]\w*"  => AID(<>.to_string());
FID: FID = r"[A-Z]\w*"  => FID(<>.to_string());

Definition: Definition = {
    "enum" <id: AID> "=" <first: Constructor> <rest: ("," <Constructor>)*> => {
        let mut constructors = vec![first];
        constructors.extend(rest.into_iter());
        Definition::ADTDefinition(ADTDefinition { id, constructors })
    },

    <signature: FunctionSignature> <id: FID> <variable: VID> Equals <body: Expression> => {
        Definition::FunctionDefinition(FunctionDefinition {
            id,
            variable,
            signature,
            body
        })
    }
}

Constructor: ConstructorDefinition = {
    <id: FID> <argument: Type> => ConstructorDefinition { id, argument } 
}

Type: Type = {
    AID => Type::ADT(<>),
    TupleType => Type::Tuple(<>),
    "Int" => Type::Int
}

TupleType: TupleType = {
    "(" <mut others: (<Type> ",")*> <last: Type?> ")" => {
        if let Some(last) = last { others.push(last); }
        TupleType(others)
    }
}

FunctionSignature: FunctionSignature = {
    <fip: "fip"?> <argument_type: Type> ":" <result_type: Type> => {
        FunctionSignature { is_fip: fip.is_some(), argument_type, result_type }
    }
}

TuplePattern: Vec<VID> = {
    "(" <mut others: (<VID> ",")*> <last: VID?> ")" => {
        if let Some(last) = last { others.push(last); }
        others
    }
}

Expression: Expression = {
    #[precedence(level="0")]
    VID => Expression::Variable(<>),
    Number => Expression::Integer(<>),
    TupleExpression => Expression::Tuple(<>),

    #[precedence(level="1")]
    <id: FID> <arg: TupleExpression> => Expression::FunctionCall(id, Box::new(arg)),

    #[precedence(level="2")] #[assoc(side="left")]
    <e1: Expression> "*" <e2: Expression> => Expression::Operation(Operator::Mul, Box::new(e1), Box::new(e2)),
    <e1: Expression> "/" <e2: Expression> => Expression::Operation(Operator::Div, Box::new(e1), Box::new(e2)),

    #[precedence(level="3")] #[assoc(side="left")]
    <e1: Expression> "+" <e2: Expression> => Expression::Operation(Operator::Add, Box::new(e1), Box::new(e2)),
    <e1: Expression> "-" <e2: Expression> => Expression::Operation(Operator::Sub, Box::new(e1), Box::new(e2)),

    #[precedence(level="4")] #[assoc(side="left")]
    <e1: Expression> "==" <e2: Expression> => Expression::Operation(Operator::Equal, Box::new(e1), Box::new(e2)),
    <e1: Expression> "!=" <e2: Expression> => Expression::Operation(Operator::NotEqual, Box::new(e1), Box::new(e2)),
    <e1: Expression> ">" <e2: Expression> => Expression::Operation(Operator::Greater, Box::new(e1), Box::new(e2)),
    <e1: Expression> ">=" <e2: Expression> => Expression::Operation(Operator::GreaterOrEqual, Box::new(e1), Box::new(e2)),
    <e1: Expression> "<" <e2: Expression> => Expression::Operation(Operator::Less, Box::new(e1), Box::new(e2)),
    <e1: Expression> "<=" <e2: Expression> => Expression::Operation(Operator::LessOrEqual, Box::new(e1), Box::new(e2)),

    #[precedence(level="5")]
    "match" <variable: VID> "{" <cases: MatchCase+> "}" => {
        Expression::ADTMatch(ADTMatchExpression { variable, cases })
    },

    "match" <match_var: VID> <pattern_vars: TuplePattern> ":" <body: Expression> => 
        Expression::TupleMatch(TupleMatchExpression { match_var, pattern_vars, body: Box::new(body) })
}

/*
//Ambiguity without brackets or tabs

():()
amb () = match x
            A (): ...
            B (): match y 
                C (): ...
                D (): ...

// OR IS IT

():()
amb () = match x {
            A (): ...
            B (): match y {
                C (): ...
            },
            D (): ...
        }

*/

MatchCase: ADTMatchCase = {
    <cons_id: FID> <var: VID> ":" <body: Expression> => ADTMatchCase { cons_id, var, body }
}

TupleExpression: TupleExpression = {
    "(" <mut others: (<Expression> ",")*> <last: Expression?> ")" => {
        if let Some(last) = last { others.push(last); }
        TupleExpression(others)
    }
}

Number: i32 = r"(\+|-)?[0-9]+" => i32::from_str(<>).unwrap();
Equals: () = "=" => ();