use crate::ast::*;
use crate::lexer::{Token, LexicalError};

grammar;

extern {
    type Location = usize;
    type Error = LexicalError;

    enum Token {
        "id" => Token::Identifier(<String>),
        "int" => Token::Integer(<i64>),
        "(" => Token::LParen,
        ")" => Token::RParen,
        "{" => Token::LBrace,
        "}" => Token::RBrace,
        ":" => Token::Colon,
        "," => Token::Comma,
        "=" => Token::Equal,
        "_" => Token::Wildcard,
        "fip" => Token::Fip,
        "match" => Token::Match,
        "enum" => Token::Enum,
        "+-" => Token::PlusMinus(<String>),
        "*/" => Token::MultiplyDivide(<String>),
        "cmp" => Token::Comparator(<String>),
        ";" => Token::EOL
    }
}

pub Program: Program = {
    Definition* => Program(<>)
}

#[inline]
Pattern: Option<String> = {
    "id" => Some(<>),
    "_" => None
}

Definition: Definition = {
    "enum" <id: "id"> "=" <first: Constructor> <rest: ("," <Constructor>)*> ";" => {
        let mut constructors = vec![first];
        constructors.extend(rest.into_iter());
        Definition::ADTDefinition(ADTDefinition { id, constructors })
    },

    <signature: FunctionSignature> <id: "id"> <variable: Pattern> "=" <body: Expression> ";" => {
        Definition::FunctionDefinition(FunctionDefinition {
            id,
            variable: variable.unwrap_or_else(|| generate_wildcard_vid()),
            signature,
            body
        })
    }
}

Constructor: ConstructorDefinition = {
    <id: "id"> <argument: Type> => ConstructorDefinition { id, argument } 
}

Type: Type = {
    "id" => {
        if <> == "Int" { Type::Int }
        else { Type::ADT(<>) }
    },
    TupleType => Type::Tuple(<>),
}

TupleType: TupleType = {
    "(" <mut others: (<Type> ",")*> <last: Type?> ")" => {
        if let Some(last) = last { others.push(last); }
        TupleType(others)
    }
}

#[inline]
FunctionSignature: FunctionSignature = {
    <fip: "fip"?> <argument_type: Type> ":" <result_type: Type> => {
        FunctionSignature { is_fip: fip.is_some(), argument_type, result_type }
    }
}

TuplePattern: Vec<VID> = {
    "(" <mut others: (<"id"> ",")*> <last: "id"?> ")" => {
        if let Some(last) = last { others.push(last); }
        others
    }
}

Expression: Expression = {
    #[precedence(level="0")]
    "id" => Expression::Variable(<>),
    "int" => Expression::Integer(<>),
    TupleExpression => Expression::Tuple(<>),

    #[precedence(level="1")]
    <id: "id"> <arg: Expression> => Expression::FunctionCall(id, Box::new(arg)),

    #[precedence(level="2")] #[assoc(side="left")]
    <e1: Expression> <op: "*/"> <e2: Expression> => {
        Expression::Operation(
            if op == "*" { Operator::Mul } else { Operator::Div }, 
            Box::new(e1), 
            Box::new(e2)
        )
    },

    #[precedence(level="3")] #[assoc(side="left")]
    <e1: Expression> <op: "+-"> <e2: Expression> => {
        Expression::Operation(
            if op == "+" { Operator::Add } else { Operator::Sub }, 
            Box::new(e1), 
            Box::new(e2)
        )
    },

    #[precedence(level="4")] #[assoc(side="left")]
    <e1: Expression> <op: "cmp"> <e2: Expression> => {
        let operation = match op.as_str() {
            "==" => Operator::Equal,
            "!=" => Operator::NotEqual,
            "<" => Operator::Less,
            "<=" => Operator::LessOrEqual,
            ">" => Operator::Greater,
            ">=" => Operator::GreaterOrEqual,
            _ => panic!("???")
        };

        Expression::Operation(operation, Box::new(e1), Box::new(e2))
    },

    #[precedence(level="5")]
    "match" <variable: "id"> "{" <cases: MatchCases> "}" => {
        Expression::ADTMatch(ADTMatchExpression { variable, cases })
    },

    "match" <match_var: "id"> <pattern_vars: TuplePattern> ":" <body: Expression> => 
        Expression::TupleMatch(TupleMatchExpression { match_var, pattern_vars, body: Box::new(body) })
}

#[inline]
MatchCases: Vec<ADTMatchCase> = {
    <first: MatchCase> <rest: ("," <MatchCase>)*> => {
        let mut cases = vec![first];
        cases.extend(rest);
        cases
    }
}

#[inline]
MatchCase: ADTMatchCase = {
    <cons_id: "id"> <var: Pattern> ":" <body: Expression> => ADTMatchCase { 
        cons_id, 
        var: var.unwrap_or_else(|| generate_wildcard_vid()),
        body 
    }
}

#[inline]
TupleExpression: TupleExpression = {
    "(" <mut others: (<Expression> ",")*> <last: Expression?> ")" => {
        if let Some(last) = last { others.push(last); }
        TupleExpression(others)
    }
}