use crate::ast::*;

grammar;

identifier = r"";

pub Program: Program = {
    Definition* => Program(<>)
}

Definition: Definition = {
    "enum" <id: Identifier> "=" <first: Constructor> <rest: ("," <Constructor>)*> ","? => {
        let mut constructors = vec![first];
        constructors.extend(rest.into_iter());
        Definition::ADTDefinition(ADTDefinition { id: AID(id.to_string()), constructors })
    },

    <signature: FunctionSignature> <id: Identifier> <variables: TuplePattern> Equals => {
        Definition::FunctionDefinition(FunctionDefinition {
            id: FID(id.to_string()),
            variables,
            signature,
            body: Expression::Integer(1)
        })
    }
}

Constructor: ConstructorDefinition = {
    <id: Identifier> <argument: TupleType> => ConstructorDefinition { id: FID(id.to_string()), argument } 
}

Type: Type = {
    Identifier => Type::ADT(AID(<>.to_string())),
    TupleType => Type::Tuple(<>),
    "Int" => Type::Int
}

TupleType: TupleType = {
    "(" <mut others: (<Type> ",")*> <last: Type?> ")" => {
        if let Some(last) = last { others.push(last); }
        TupleType(others)
    }
}

FunctionSignature: FunctionSignature = {
    <fip: "fip"?> <argument_type: TupleType> ":" <result_type: Type> => {
        FunctionSignature { is_fip: fip.is_some(), argument_type, result_type }
    }
}

TuplePattern: Vec<VID> = {
    "(" <mut others: (<Identifier> ",")*> <last: Identifier?> ")" => {
        if let Some(last) = last { others.push(last); }
        others.into_iter().map(|x| VID(x.to_string())).collect::<Vec<_>>()
    }
}

Identifier: &'input str = r"[[:alpha:]]\w*"  => <>;
Equals: () = "=" => ();